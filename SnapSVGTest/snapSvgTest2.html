<!DOCTYPE html>
<html>
<style type="text/css">
	* { margin: 0; padding: 0; }
	html, body { height: 100%; width: 100%; }
	
	body
	{
		background-color: #000000;
		-moz-user-select:   none; 
	}
</style>
<script type="text/javascript" src="problems.js"></script>  	
<script type="text/javascript" src="brainPuzzle.js"></script>  
<script type="text/javascript" src="commonFuncs.js"></script>  
<script src="../SnapSVG/dist/snap.svg.js"></script>
<script type="text/javascript" > 

	var bkSvg;
	var frontSvg;
	
	var BLOCK_SIZE = 35;
	var GRID_SIZE = BLOCK_SIZE + 1;

	var INVALID_BK_COLOR = "black";
	var VALID_BK_COLOR = "grey";
	var HOVER_IN_BK_STROKE = "red";
	var HOVER_OUT_BK_STROKE = "black";

	function drawSingleGroup(group, angle, mirrorX)
	{
		var ptLen = group.points.length;
		var svgGroup = frontSvg.group();
		svgGroup.attr({
				id: group.name,
				});
		
		var org = group.points[0];
		for(var j = 0; j<ptLen; j++)
		{
			var pt = {x: group.points[j].x, y:group.points[j].y};
			
			if(mirrorX == 1)
				pt.y = -pt.y;
				
			var rpt = rotateByPoint(pt.x, pt.y, org.x, org.y, angle);
			var rect = frontSvg.rect(rpt.x*GRID_SIZE , rpt.y*GRID_SIZE , BLOCK_SIZE, BLOCK_SIZE);
			
			// By default its black, lets change its attributes
			rect.attr({
				fill: group.color,
				stroke: "blue",
				strokeWidth: 2
			});
			
			svgGroup.add(rect);
		}
		
		return svgGroup;
	}
	
	
	function drawGroups()
	{
		var len = brainPuzzleBlocks.length;
		for(var i=0; i<len; i++)
		{	
			var temp = i % 3;
			var row = (i - temp) / 3;
			var offsetX = 500 + 200 * temp;
			var offsetY = 80 + 150 * row;
			
			//alert(brainPuzzleBlocks[i].name);
			var group = brainPuzzleBlocks[i];
			var ptLen = group.points.length;
			
			var svgGroup = frontSvg.group();
			svgGroup.attr({
					id: group.name,
					});
					
			for(var j = 0; j<ptLen; j++)
			{
				var pt = group.points[j];
				var rect = frontSvg.rect(pt.x*GRID_SIZE , pt.y*GRID_SIZE , BLOCK_SIZE, BLOCK_SIZE);
				
				// By default its black, lets change its attributes
				rect.attr({
					fill: group.color,
					stroke: "blue",
					strokeWidth: 2
				});
				
				svgGroup.add(rect);
				svgGroup.attr({
						transform: 'T' + [offsetX, offsetY]
					});
			}
				
				
			var move = function(dx,dy) {
			this.attr({
						transform: this.data('origTransform') + (this.data('origTransform') ? "T" : "t") + [dx, dy]
					});
}

			var start = function() {
					this.data('origTransform', this.transform().local );
			}
			var stop = function() {
					
					var id = this.attr("id");
					console.log(id + ' finished dragging');
					var block = document.getElementById(id);
					var transMatrix = block.getCTM();
					alert(transMatrix);
					console.log(transMatrix);
			}

				
				
				
			svgGroup.drag(move, start, stop); 
			//svgGroup.drag();
			svgGroup.dblclick(onDbClickBlock);
		}
		//Snap("#L").remove();
	}
	
	function matrixToStr(matrix)
	{
		var transformStr = "matrix(" + matrix.a + "," + matrix.b + "," + matrix.c + "," 
					+ matrix.d + "," + matrix.e + "," + matrix.f + ")";
		return transformStr;
	}

	function mirrorByLine(elem, a, b, c) //line: ax + by + c = 0
	{
		var s = 1/(a*a + b*b);
		
		var transMatrix = elem.getCTM();
		var newMatrix = svgRoot.createSVGMatrix();
		newMatrix.a = s*(b*b - a*a);
		newMatrix.b = s*(0 - 2*a*b);
		newMatrix.c = s*(0 - 2*a*c);
		newMatrix.d = newMatrix.b;
		newMatrix.e = s*(a*a - b*b);
		newMatrix.f = s*(0 - 2*b*c);
		
		var resultMatrix = svgRoot.createSVGMatrix();
		resultMatrix.a = newMatrix.a * transMatrix.a + newMatrix.b * transMatrix.d;
		resultMatrix.b = newMatrix.a * transMatrix.b + newMatrix.b * transMatrix.e;
		resultMatrix.c = newMatrix.a * transMatrix.c + newMatrix.b * transMatrix.f + newMatrix.c;
		resultMatrix.d = newMatrix.d * transMatrix.a + newMatrix.e * transMatrix.d;
		resultMatrix.e = newMatrix.d * transMatrix.b + newMatrix.e * transMatrix.e;
		resultMatrix.f = newMatrix.d * transMatrix.c + newMatrix.e * transMatrix.f  + newMatrix.f;
		
		//好像没有setCTM函数，因此需要将矩阵转换为transformStr，然后通过属性赋值
		var transformStr = matrixToStr(resultMatrix);
		//alert(transformStr);
		
		elem.setAttributeNS(null, "transform", transformStr);
	}
	

	function updateImage(elem, cx, cy, rotateFlag, rx, ry)
	{
		var sin, cos;
		if(rotateFlag == 1) //90
		{
			sin = 1;
			cos = 0;
		}
		else if(rotateFlag == 2) //180
		{
			sin = 0;
			cos = -1;
		}
		else if(rotateFlag == 3) //270
		{
			sin = -1;
			cos = 0;
		}
		else //default 0
		{
			sin = 0;
			cos = 1;
		}
		
		var transMatrix = elem.getCTM();
		var newMatrix = svgRoot.createSVGMatrix();
		newMatrix.a = transMatrix.a * cos - transMatrix.b * sin;
		newMatrix.b = transMatrix.a * sin + transMatrix.b * cos;
		newMatrix.c = transMatrix.c * cos - transMatrix.d * sin;
		newMatrix.d = transMatrix.c * sin + transMatrix.d * cos;
		newMatrix.e = transMatrix.e * cos - transMatrix.f * sin - rx * cos + ry * sin + rx + cx ;
		newMatrix.f = transMatrix.e * sin + transMatrix.f * cos - rx * sin - ry * cos + ry + cy ;
		
		//好像没有setCTM函数，因此需要将矩阵转换为transformStr，然后通过属性赋值
		var transformStr = matrixToStr(newMatrix);
		//alert(transformStr);
		
		elem.setAttributeNS(null, "transform", transformStr);
	}
	
	function onDbClickBlock(evt)
	{
		var id = this.attr("id");
		var block = document.getElementById(id);
		
		//Mirror by Y=evt.y, so a=0, b=1, c=-evt.y
		mirrorByLine(block, 0, 1, -evt.y);
		
		//Move and rotate
		//updateImage(block, 0, 0, 1, evt.x, evt.y);
		
		//var matrixStr = Snap.matrix(this);
		//var m = Snap.parseTransformString(matrixStr);		
		//alert(matrixStr);
		//alert(this.transform(matrixStr));
	}
	
	function onDragStart(posx, posy) {
 
	}

	var currentElement = null;
	
	function onDragMove(dx, dy, posx, posy) {
		this.attr({
                    transform: this.data('origTransform') + (this.data('origTransform') ? "T" : "t") + [dx, dy]
                });
		
		var topElement = Snap.getElementByPoint(posx, posy);
		if(topElement == currentElement)
			return;
		
		
				
		if(topElement != null)
		{
			topElement.attr({strokeWidth: 5});	
			if(currentElement != null)
				currentElement.attr({strokeWidth: 2});
		}	
		
		currentElement = topElement;
/*		
	
		var col = Math.cell(posx / GRID_SIZE);
		var row = Math.cell(posy / GRID_SIZE);
		var idStr = "BkGrid_" + col + "_" + row;
		if(idStr == currentIdStr)
			return;
		else
		{
			if(currentIdStr != null)
			{
				SelectRect(currentIdStr, false);
			}
			
			SelectRect(idStr, true);
			currentIdStr = idStr;
		}*/
	}


	function onDragEnd(event)
	{
		//alert(event.x + "," + event.y);
		var id = this.attr("id");
		var block = document.getElementById(id);
		var transMatrix = block.getCTM();
		alert(transMatrix);

	}
	
	
	function highlightBlock(posArray, color, width) 
	{
		for(var j=0; j<posArray.length; j++)
		{
			var pos = posArray[j];
			var id = "#BkGrid_" + pos.col + "_" + pos.row;
			//var color = brainPuzzleBlocks[solutionStack[i].blockIndex].color;
			var rect = Snap(id);
			rect.attr({
				stroke: color,
				strokeWidth: width});
		}
	}
	
	function drawBlock(posArray, color) 
	{
		for(var j=0; j<posArray.length; j++)
		{
			var pos = posArray[j];
			var id = "#BkGrid_" + pos.col + "_" + pos.row;
			//var color = brainPuzzleBlocks[solutionStack[i].blockIndex].color;
			var rect = Snap(id);
			rect.attr({
				fill: color,});
		}
	}
	
	function drawSolution()
	{
		for(var i=0; i<solutionStack.length; i++)
		{
			var color = brainPuzzleBlocks[solutionStack[i].blockIndex].color;
			drawBlock(solutionStack[i].pos, color);
		}
	}
	
	function gameStart()	
	{	
		console.log('Start...');
		
		//Get all possible position
		for(var i=0; i<brainPuzzleBlocks.length; i++)
		{
			testGroupOnGrid(i);
		}
		
		console.log(resultArray);
		console.log('Find all positions ');
		
		findSpecificSolution();
		//findFirstSolutionWithoutA();
	}	

	var svgRoot;
	
	window.onload = function() 
	{
		svgRoot = document.getElementById('svgRoot');
		//初始化有效点和背景矩阵
		initValidPoints();
		BK_GRIDS = initBrainPuzzleGrids()
		//initSolution();
		
		// First lets create our drawing surface out of existing SVG element
		// If you want to create new surface just provide dimensions
		// like s = Snap(800, 600);
		bkSvg = Snap("#svgFront");
		frontSvg = Snap("#svgFront");
		
		for(var i=0; i<VALID_POINTS.length; i++)
		{
			var rect = bkSvg.rect(VALID_POINTS[i].col*GRID_SIZE, VALID_POINTS[i].row*GRID_SIZE, BLOCK_SIZE, BLOCK_SIZE);
			// By default its black, lets change its attributes
			rect.attr({
				id: "BkGrid_" + VALID_POINTS[i].col + "_" + VALID_POINTS[i].row,
				fill: VALID_BK_COLOR,
				stroke: HOVER_OUT_BK_STROKE,
				strokeWidth: 1
			});
			
			var hoverIn = function() {
					this.attr({stroke: HOVER_IN_BK_STROKE, strokeWidth: 2});
			}
			var hoverOut = function() {
					this.attr({stroke: HOVER_OUT_BK_STROKE, strokeWidth: 1});
			}
			rect.hover(hoverIn, hoverOut);
		}
		
		drawGroups();
	}
	
</script>  
</head>  
  
<body oncontextmenu="return false" onselectstart="return false" oncopy="return false">
	<svg id="svgRoot" width="100%" height="100%" style="position:absolute" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"></svg>
	<svg id="svgFront" width="100%" height="100%" style="position:absolute" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"></svg>
    <input type="button" onclick="gameStart()" style="position:absolute;left:200px;top:400px;cursor:pointer;-moz-user-select:none;-webkit-user-select:none;" value="Start find">
</body>   
</html>  